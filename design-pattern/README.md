# デザインパターン

## Factory Method
* インスタンスの生成をサブクラスに任せる。
* newすることの問題点。
  * 生成するインスタンスに変更が入った場合、改修が面倒臭い。
  * 複雑なインスタンス生成処理を行う場合、そのようなコードが複数箇所にできてしまう。
    * インスタンス化前後の処理が発生してしまうケース。
* Factoryをstaticにして、内部の分岐でどのインスタンスを返すか作成するパターンもあり。
  * StaticFactory.java
  * Factoryクラスを1つにできる。
* FactoryMethodパターンを用いる場合、クラス名の末尾に*Factoryをつけるなどして分かりやすくする。


## Abstract Factory
* 1つの製品・サービスを提供する際、必要な部品が複数個あり、それらが関連している場合、部品とそれを生成する工場を抽象化する。
  * 切り替えの指標を見て、部品をごそっと切り替える。
* getFactoryメソッド内ではClassクラスを使ってインスタンスを生成している。
  * if分などで分岐処理を入れると、拡張があった際にFactoryクラスの修正が必要になる。
  * Classクラスを使った動的なメソッド呼び出しをリフレクションと呼ぶ。
  * OsFactoryへキャストしている箇所は、インターフェースを導入することでキャストの記述をなくせる？
* 利用ケース
  * Productが複数存在するケース
  * Productを拡張する必要がある場合
  * 実行環境に追加や変化が生じる場合
  
  
## Builder
* Builderはインスタンスを作る為のインターフェースを提供する。
* DirectorクラスはBuilderクラスのみ呼び出している。
  * DirectorはBuilderクラスのメソッドを組み合わせて、オブジェクトを作ってくれる人。
* 利用ケース
  * 段階的にインスタンスを生成する場合
    * インスタンス生成のコードを一箇所にまとめることができる。
  * インスタンス生成プロセスが多様な場合
    * オブジェクトを生成するプロセスが複数ある場合、constructメソッドを複数用意する。
    

## Prototype
* 原型となるオブジェクトを用意しておいて、使うときはそのコピー(初期値を設定して)を使用する。
* 例としてはGUIの各パーツなど。
* itemインターフェースのメソッドを通してitemオブジェクトをインスタンス化する。
  * サブクラスが追加されてもManagerに修正が及ばない。
* 少しだけ違う(フィールドを持つ)オブジェクトを量産する場合に使う。


## Singleton
* 全体でインスタンスが1つしか存在しないことが保証されるクラスを作成する。
* フィールド変数を持っていたら、ただのグローバル変数と何が違うのだろうか疑問。

## State
* 状態を表すクラスを導入 → 状態による分岐(if, switchなど)をなくし、拡張性を高くする。
* ソース例
  * 店の営業時間で処理を分岐させたい。
  * 新しい状態が欲しければ、クラスを実装すればいいだけなので楽。
  * 「状態に依存する処理」を追加する必要が出てきた際の懸念事項
    * インターフェースにメソッドを追加する → サブクラスでも実装が必要 → テストの修正も必要
    * **インターフェースの導入はクラスの追加は容易になるが、メソッドの追加は大変**
  * 状態遷移が出てきたら気を遣う必要がある。
* ソースメモ
  * Shop
    * 状態による処理を利用するAPI
    * 現在の状況(状態:context)を持つ
