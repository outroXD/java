# 2章 オブジエクトの生成と消滅
## 項目1 コンストラクタの代わりにstaticファクトリメソッドを検討する
* `サブタイプ`
  * あるプログラムに対して、型Sを型Tと見なすことができる場合、「SはTのサブタイプである」という。
  * = サブクラス、派生クラス
* `派生クラス`
  * クラスの親子関係が成り立つ場合の子側のクラスのことである。
* クラスのインスタンスを使う方法。
  * publicコンストラクタの提供。
  * publicのstaticファクトリメソッドの提供。
    * クラスのインスタンスを返却するstaticメソッド。
* publicのstaticファクトリメソッド。
  * 長所
    * 名前を持つ。
      * コンストラクタだと名前はクラス名に限定される。
      * BigInteger(int, int, Random)よりBigInteger.probablePrimeというstaticファクトリメソッドの方がわかりやすい。
    * コンストラクタと異なり、呼び出し毎に新たにオブジェクトを生成する必要がない。
      * immutableクラス、オブジェクトのキャッシュ。
      * シングルトン、インスタンス化不可にできる。
    * コンストラクタと異なり、メソッドの戻り値型の任意のサブタイプのオブジェクトを返せる。
    * 返されるオブジェクトのクラスは、入力パラメータの値に応じて呼び出し毎に変えられる。
  * 短所
    * 戻り値型のサブクラスを作れない。
    
## 項目2 多くのコンストラクタパラメータに直面したときにはビルダーを検討する
* 多くのオプションパラメータがある場合にどうするかという問題。
* `テレスコーピング・コンストラクタ・パターン`が使われてきた。
  * コンストラクタを引数で数パターン用意するやり方。
* `JavaBeansパターン`
  * setterによりセットする。パラメータの正統性を確保できない。
  * setterで内部の状態を変更できるので、クラスを不変にできない。
* `Builderパターン`
  * build()でインスタンス化する前に、パラメータ間の不整合を検知できる。
  * クラス階層
  * `共変戻り値型付け`
    * サブクラスのメソッドが、スーパークラスで宣言された戻り値型のサブタイプを返すと宣言する技法。
    * 具体例はchap2のソース。
    
## 項目3 privateのコンストラクタかenum型でシングルトン特性を強制する
* シングルトンの雛形
* staticファクトリメソッドによる実装の長所。
  * ジェネリックのシングルトンファクトリをかける。
* シリアライズ可能なシングルトンクラスの実装。
  * `implements Serializable`を実装する。
  * 全てのインスタンスフィールドを`@transient`と宣言する。
  * `readResolve`メソッドを提供する。

## 項目4 privateのコンストラクタでインスタンス化不可能を強制する
* staticなフィールド・メソッドだけで構成されるクラスは、一般的にユーティリティクラスと呼ばれる。
  * そのようなクラスは本来インスタンス化して使うものではないが、コンストラクタが使えるとインスタンス化される恐れがある。
* クラスを抽象化してインスタンス化できないことを強制する。
  * そのクラスのサブクラスは作れてしまう。
  * サブクラスはインスタンス化できてしまう。
  * 継承して使うものだとユーザーを錯覚させてしまう。
* クラスのインスタンス化をできないようにする。
  * クラスにprivateのコンストラクタを含める。
  * 全てのコンストラクタは、明示的・暗黙的にスーパークラスのコンストラクタを呼び出さなければならないので、サブクラス化することも防げる。
  
## 項目5 資源を直接結び付けるよりも依存性注入を選ぶ
* 複数のインスタンスに対するサポートを提供するユーティリティ系の実装について。
  * シングルトンや静的(static)ユーティリティは不適。
  * シングルトンクラスや静的ユーティリティクラスが内部に状態を持つと、テストしづらく、状態の切り替えが必要になった時対応できない。
  * setterで内部状態にアクセス可能にする方法も考えられるが、利用者にとってわかりづらく、スレッドセーフでもない。
* `依存性注入`
  * 新しいインスタンスを生成するときにコンストラクタに資源を渡す。
* `ファクトリ`
  * 依存性注入の応用形。
  * コンストラクタに資源ファクトリを渡す。
  * `Supplier<T>`はファクトリを表現するにに最適。
### `Supplier<T>`について。
* 引数を取らないけど、返り値は存在する挙動を定義するためのインターフェース。
* 具体例
    ```java
    // 引数なしで、型Tのインスタンスを返却する関数を実装
    Supplier<T> supplier = () -> new T();
    // 実際に呼び出す
    supplier.get();
    ```
* get()が呼ばれるまで処理が行われない為、遅延評価とも呼ばれる。

## 項目8 ファイナライザーとクリーナーを避ける
* 原則としてファイナライザの使用は避ける。
* Java9からは代替としてクリーナーが存在する。
* ファイナライザ・クリーナーの欠点
  * 即座に実行される保証がない。
    * 実行までに時間がかかる場合があるので、速度の求められる場面で使うべきではない。
    * JVMの実装により、実行までの時間は異なる。
  * ファイナライズの処理中にスローされた例外がキャッチされなかった場合、オブジェクトの状態を不正なままにしてしまう可能性がある。
    * 通常キャッチされなかった例外はスレッドを終了さセル。
   
    
# 3章 すべてのオブジェクトに共通のメソッド
## 項目10 equalsをオーバーライドするときは一般契約に従う
* Objectに所属するfinalでない全てのメソッドはオーバーライドされるように設計されていて、明示的な`一般契約`を持っている。
  * 一般契約に従うことは、それらメソッドをオーバーライドするクラスの責任。

### equalsをオーバーライドしないのが正しい場合
  * クラスのここのインスタンスがシステム上一意である。
  * クラスのインスタンス同士で論理的等価性を検査する必要がない
  * スーパークラスが既にequalsをオーバーライドしていて、スーパークラスの振る舞いがこのクラスに対して適切である。
  * クラスがprivateあるいはパッケージプライベートであり、そのequalsメソッドが呼び出されないことが確かである。

###equalsをオーバーライドするのが正しい場合
* クラスが`論理的等価性`という概念を持っていて、かつスーパークラスがequalsをオーバーライドしていないとき。
  * `値クラス`であるとき。

#### equalsメソッドをオーバーライドするときの一般契約(同値関係)
* `同値関係`とは要素の集合を、互いに等しいと思える要素を持つ部分集合に分割する演算子。
* 一般契約を破ってしまうと、他のオブジェクトがその契約を破っているオブジェクトを扱う時、どのように振舞うか分からない。
##### 同値関係の性質
* 反射的
  * オブジェクトがそれ自身と等しくなることを保証する。
* 対称的
  * いかなる2つのオブジェクトでも、それらが等しいかどうかについて合意しなければならない。
* 推移性
  * 1つ目のオブジェクトが2爪のオブジェクトと等しく、2つ目のオブジェクトが3つ目のオブジェクトと等しい場合、1つ目のオブジェクトは3つ目のオブジェクトと等しくなければならない。
  * インスタンス化可能なクラスを拡張して、equalsの契約を守ったまま値要素を追加する方法はない。
  * 継承よりコンポジションを選ぶことで、上記問題を回避できる。
* 整合的
* nullではない任意の参照値xに対して、x.equals(null)はfalseを返さなければならない。

## 項目12 toStringを常にオーバーライドする
* toStringをオーバーライドして優れた実装を提供することはデバッグに役立つ。
* 実用的なtoStringメソッドはオブジェクトに含まれる、興味がある全ての情報を含むべき。
  * 電話番号のような`値クラス`は明示するべき。
* toStringが出力する値の「意図」はコメントで明示する。

## 項目14 Comparableの実装を検討する
* equalsと比べて単純な同値比較に加えて順序比較を許している点が異なる。
* クラスがComparableを実装することで、インスタンスが自然な順序を持っていることを示せる。
  * 例：アルファベット順、数値順、年代順など
### Comparableをオーバーライドするときの一般契約
* compareToの契約を破っているクラスは比較に依存している他のクラスを機能させなくする。
1. `sgn(x.compareTo(y)) == -sgn(y.compareTo(x))`を保証する。
   * 2つのオブジェクト参照間での比較の向きを逆にした場合に上記が成り立つこと。(= 順序を逆にして比較した場合、結果の符号も逆になる)
   * 1つ目のオブジェクトが2つ目のオブジェクトより小さければ、2つ目のオブジェクトは1つ目のオブジェクトよりも大きくなければならない。
   * 1つ目のオブジェクトが2つ目のオブジェクトと等しければ、2つ目のオブジェクトは1つ目のオブジェクトと等しくなければならない。
   * 1つ目のオブジェクトが2つ目のオブジェクトより大きければ、2つ目のオブジェクトは1つ目のオブジェクトよりも小さくなければならない。
2. `(x.compareTo(y) > 0 && y.compareTo(z) > 0)なら、x.compareTo(z) > 0`
   * 推移的な関係を満たす。
3. `x.compareTo(y) == 0なら、sgn(x.compareTo(z)) == sgn(y.compareTo(z))`
   * xとyの順序が等しいなら、それぞれを他のオブジェクトzと比較したとき、同じ結果にならなければならない。
4. `x.compareTo(y) == 0 なら、x.equals(y)はtrueになるし、その逆も成立する`
   * この条件は必須ではないが、満たすことが好ましい。

* (1)〜(3)に関しての注意点
  * Comparableを実装している既存のクラスがあったとして、それを継承して新たなフィールドを追加する場合、これらの要件を満たすことはできない。
    * 軽症ではなくコンポジションを使う。
  * sgn(expression)は、expressionが負、ゼロ、正の時にそれぞれ-1, 0, 1を返す関数。
* (4)に関しての注意点
  * この契約を破っている場合、Collections、Set、Mapの一般契約に従わないかもしれないので、適切に機能しないかもしれない。
    * ソートされたコレクションはequalsの代わりにcompareToにより行われる同値検査を使っているから。


* compareToメソッドでは同値比較ではなく、順序比較される。
  * オブジエクト参照の比較には、compareToメソッドを再帰的に呼び出す。
    * compareToにおいてそれらを比較する順序は重要。意味のあるフィールドから、意味の弱いフィールドの順に比較を行う。
    
### 実装例
```java
public int compareTo(PhoneNumber pn) {
  int result = Short.compare(areaCode, pn.areaCode);
  if (result == 0) {
    result = Short.compare(prefix, pn.prefix);
    if (result == 0) {
      result = Short.compare(lineNum, pn.lineNum);
    }
  }
  return result;
}
```
Java8以降ではコンパレータ構築メソッドを使って以下のようにもかける。
```java
private static final Comparator<PhoneNumber> COMPARATOR = 
    comparingInt((PhoneNumber pn) -> pn.areaCode)
        .thenComparingInt(pn -> pn.prefix)
        .thenComparingInt(pn -> pn.lineNum);

public int compareTo(PhoneNumber pn) {
    return COMPARTOR.compare(this, pn);
}
```
以下のようなcompareTo, compareイディオムが書かれていることがあるが、`整数オーバーフロー`と`浮動小数点の副作用`の危険性がある。  
また推移性も満たしていない。
```java
static Compare<Object> hashCodeOrder = new Comparator<>() {
    public int compare(Object o1, Object o2) {
        return o1.hashCode() - o2.hashCode();
    }
}
```
良い例が下記。
```java
static Compare<Object> hashCodeOrder = new Comparator<>() {
    public int compare(Object o1, Object o2) {
        return Integer.compare(o1.hashCode(), o2.hashCode());
    }
}

static Comparator<Object> hashCodeOrder = 
    Comparator.comparingInt(o -> o.hashCode());
```
compareToメソッドの実装ないでフィールドの値を比較するときは、`>`, `<`を使わないこと。  
compareメソッドやコンパレータ構築メソッドを使用する。


# 4章 クラスとインターフェース
## 項目15 クラスとメンバーへのアクセス可能性を最小限にする
### 情報隠蔽・カプセル化
コンポーネントの外部からアクセスできる部分(公開API)を最小限にすること。  
public, protectedで宣言するもの。
### 情報隠蔽・カプセル化をする理由
コンポーネントを個別に開発・テスト・最適化・利用・理解・修正するため。  
### 情報隠蔽・カプセル化をどうやるか
1. クラス・インターフェース・メンバーのアクセス可能性を指定する。
2. 大まかなやり方は各クラスやメンバーへのアクセスを可能な限りできないようにする。
3. トップレベルのクラス
  * パッケージプライベート
    * パッケージの公開APIではないと言う解釈ができる。
  * public
4. 可変なオブジェクト(Listの要素とか)は利用者に中身を変更されてしまう恐れがあるので、定数として公開するのはNG。代わりに不変なオブジェクトに変換して公開するか、コピーを返すべき。
#### 4. 不変なオブジェクト・コピーを返す
```java
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = 
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```
```java
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

## 項目16 publicのクラスでは、publicのフィールドではなく、アクセっさーメソッドを使う
### getter/setterを使う理由
* フィールドに直接アクセスするとカプセル化することで得られる恩恵を得られない。
* APIを変更せず、表現形式(=型?)を変更できない。
* 不変式の強制ができない。
* フィールド変更時の補助処理ができない。
  * バリデーション
  * フィールド間の整合性チェックなど
  
## 項目17 可変性を最小限にする
### 利点
* `不変クラス`とはそのインスタンスが変更できないクラスで、設計・実装・使用が可変クラスより容易。
* クラスを不変にできないのであれば、その可能性をできるだけ制限するべき。
  * 妥当な理由がない限りすべてのフィールドをprivate finalと宣言するべき。
* スレッドセーフ。
* インスタンスを共有できるので、オブジェクト生成コスト・メモリ消費量を抑えられる。
* `エラーアトミック性`を持つ。
  * 失敗する前の状態にオブジェクトが戻る性質。
  * 可変オブジェクトでエラーアトミック性を実現するのは手間がかかるが、不変性を持つオブジェクトはその性質上手間がかからない。
### 欠点
* 異なる値を持つような処理を不変オブジェクトを使って処理する場合、システム資源を消費する。
  * 複数処理ステップを1つの公開APIにまとめる。
  * Stringに対するStringBuilderのような、publicな可変コンパニオンクラスを提供する。
### 不変クラスの実装方法
1. オブジェクトの状態を変更するためのメソッドを提供しない。
   * setterなどのオブジェクトの内部状態を変更できるメソッドを提供しない。
2. クラスを拡張できないようにする。
   * 不注意なサブクラス・悪意のあるサブクラスが、オブジエクトの状態が変更されたかのように振舞うことで、クラスの不変な振る舞いを損なわないようにする。
   * サブクラス化を防ぐ → クラスをfinalにする。or コンストラクタをprivateにしてstaticファクトリメソッドを提供する。
3. すべてのフィールドをfinalにする。
   * そのフィールドは変更不可になり、スレッド間でのインスタンスの参照を安全に受け渡しできる。
4. すべてのフィールドをprivateにする。
   * 使用者がフィールドを参照して、可変オブジェクトの状態を変更できないようにする。
5. 可変コンポーネントに対する独占的アクセスを保証する。
   * クラスが可変オブジェクトのフィールドを持っているなら、そレを直接変更できないようにする。
   * コンストラクタ、アクセッサー、readObjectメソッド内では防御的コピーをする。
#### 3. クラスを拡張できないようにする
staticファクトリメソッドを使用する例。
```java
public class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public static Complex valueOf(double re, double im) {
        return new Complex(re, im);
    } 
}
```
## 項目18 継承よりもコンポジションを選ぶ
ここで扱うのは`実装継承`(あるクラスが他のクラスを拡張した場合の)。  
継承はコードを再利用する強力な方法だが、不適切に使われると脆いソフトウェアを作り出す。  

* 継承はカプセル化を破る。
  * スーパークラスの実装に依存する。スーパークラスの実装が変更されるとサブクラスは機能しなくなる可能性がある。
  * サブクラスがスーパークラスのメソッドをオーバーライドしていなくても、スーパークラスのシグネチャが後の変更でサブクラスのメソッドと被るかもしれない。

### コンポジション
既存クラスを拡張する代わりに、新たなクラスに既存のクラスのインスタンスを参照するprivateのフィールドを持たせる。  
```java
// 転送クラス
public class ForwardingSet<E> implements Set<E> {
    private final Set<E> s;
    
    public ForwardingSet(Set<E> s) {
        this.s = s;
    }

    public void clear() {
        this.s.clear();
    }
}

public class InstrumentedSet<E> extends ForwardingSet<E> {
    // Setに累計で何回addされたかを保持する。
    private int addCount = 0;
    
    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public bool add(E e) {
        addCount++;
        return super.add(e);
    }
}
```
### 継承を選ぶ場面
* 継承先のクラスが、継承を前提に作られている。
  * JavaDocに記載されているはず。
* 継承先のクラスが、パッケージ内にのみ公開されている場合です（パッケージプライベート）。
* サブクラスがスーパークラスのサブタイプである場合。
  * `is-a関係`が存在すること。
    * 「全てのBはAであるか」

## 項目19 継承のために設計および文書化する、でなければ継承を禁止する
クラスが継承できるための設計・文書化されているとはどういうことか？  

## 項目20 抽象クラスよりもインターフェースを選ぶ
* 「複数の実装を許す型」の定義には`インターフェース`と`抽象クラス`を使うことはできる。
  * インターフェースにもdefaultが導入され、メソッドの実装を提供できるようになった。
  * 抽象クラスで実装を作る場合、サブクラスとして実装しなくてはならない。
  * Javaでは単一継承のみ許可されている。
  * **「複数の実装を許す型」の実装には基本的にインターフェースを使用する。**
### インターフェースが抽象クラスより優れる点
* 利用者は複数のインターフェースを実装できる。Javaではクラスの継承は単一継承のみしか許されていないので、抽象クラスでは複数の実装を行うことができない。
* 既存のクラスが既に何かを継承していたとしても、利用者はそのクラスにインターフェースを導入できる。抽象クラスではこれはできない。
* 利用者は既存のインターフェースを組み合わせることで、新しいインターフェースを作り出せる。これを`ミックスイン`と言う。抽象クラスでもできるが、煩雑になる。
* インターフェースであれば、コンポジションを使える。
#### ミックスイン
```java
import javax.sound.sampled.AudioFileFormat;import java.applet.AudioClip;

public interface Singer {
    AudioClip sing(Song s);
}

public interface Songwriter {
    Song compose(boolean int);
}

public interface SingerSongwriter extends Singer, Songwriter {
    AudioClip sing(Song s);
    Song compose(boolean hit);
}
```

### 実装補助・骨格実装
#### 実装補助
インターフェースのメソッドをdefaultで宣言し、インターフェース内にロジックを実装する。  
骨格実装ではなく、こちらを先に考える。
#### 骨格実装
インターフェースと抽象クラスの長所を組み合わせることができる。  
実装補助を行ったインターフェースを、抽象クラスで実装する。  
インターフェースのdefault実装ではequalsなどのObjectクラスのメソッドを実装できないなどのデメリットがあるが、抽象クラスでそれをカバーできる。

## 項目21 将来のためにインターフェースを設計する
* `定数インターフェース`
  * メソッドを持っていないインターフェースで、クラスで使用する定数のみを定義したインターフェース。
  

定数インターフェースはインターフェースのアンチパターン。  
定数は実装の詳細にあたり、インターフェースを実装するというのは、その部分を公開APIにするということ。  
実装の詳細を公開APIにしてはならない。  

### 定数を外部に提供する方法
* クラスの中に定数を追加する。
  * Integer.MAX_VALUEなど。
* enum型を使う。
* インスタンス化不可能なユーティリティクラスを使う。

#### インスタンス化不可能なユーティリティクラスの例
```java
public class PhysicalConstants {
    // インスタンス化を防ぐ
    private PhysicalConstants() {}
    
    public static final double AVOGADOROS_NUMBER = 6.022_140_857e23;
}
```

## 項目23 タグ付きクラスよりもクラス階層を選ぶ
### タグ付きクラス
* 複数のクラスが1つのクラスに詰め込まれていて、可読性が悪い。
* タグ付きクラスは継承関係で書き換える。
  * ルートは抽象クラスで共通する振る舞いを定義。
  * それを継承して、サブクラスで実装。
* 複数のクラスが一つのクラス内に詰め込まれることで、分岐が増える。
### タグ付きクラスの例
```java
class Figure {
    enum Shape { RECTANGLE, CIRCLE };
    
    // タグフィールド この図形の形
    final Shape shape;
    
    // shapeがRECTANGLEである場合にこのフィールドは使われる
    double length;
    double width;
    
    // shapeがCIRCLEである場合にだけ、このフィールドは使われる
    double radius;
    
    // 円のコンストラクタ
    Figure (double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }
    
    // 長方形のコンストラクタ
    Figure (double length, double width) {  
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch (shape) {
            case CIRCLE -> length * length;
            case RECTANGLE -> Math.PI * (radius * radius);
            default -> new AssertionError(shape);
        }
    }
}
```
### タグ付きクラスを書き換える
```java
abstract class Figure {
    abstract double area();
}

class Circle extends Figure {
    final double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    double area() {
        return Math.PI * (radius * radius);
    }
}
```

## 項目24 非staticのメンバークラスよりも、staticのメンバークラスを選ぶ
* 他のクラスからアクセスからアクセスされるクラスは、普通のクラスとして定義するべき。
* 
### ネストしたクラス
* ネストしたクラスで、その内部クラスは、それを囲んでいるクラスのみから使用されるべき。
* ネストしたクラスの種類
  * staticのメンバークラス
  * 非staticのメンバークラス
  * 無名クラス
  * ローカルクラス
  * 内部クラス
#### 普通のクラス
```java
class ClassName {
}
```
#### 無名クラス
* エンクロージングクラスの特定のメソッドでしか使わない。
* ネストしたクラスの宣言部が短い。長いと、エンクロージングクラスのメソッドが読みづらいものになってしまいます。
* 一箇所でのみインスタンス化する。
```java
class ParentClass() {
    void doSomething() {}
}

ParentClass parent = new ParentClass() {
    @Override
    void doSomething() {
        // 処理を書く。
    }
}
```
#### ローカルクラス
* ネストした宣言部分のクラスが短い。
* エンクロージングクラスの特定のメソッドでしか使わない。
* そのメソッド内の複数箇所でインスタンス化する。複数箇所で使われるなら、名前付きで宣言しておく必要がおく必要がある。
```java
class OuterA {
    void doSomething() {
        class LocalClass {
        }   
    }
}
```
#### 非staticメンバークラス
* ネストした宣言部分のクラスが長い。 or エンクロージングクラスの、複数のメソッドで利用される。
* エンクロージングクラスのインスタンスにアクセスする必要がある。非staticのメンバークラスがインスタンス化されると、そのインスタンスからエンクロージングクラスのインスタンスを、自動的に参照します。場合によってはこれがメモリリークを引き起こします。その危険性を認識した上で、利用しましょう。
```java
class Outer {
    class Inner {
    }
}
```
#### staticメンバークラス
* static宣言をすることで、エンクロージングオブジェクトへの参照を保存する。よってGCされない。
  * またstatic宣言をしないと、各オブジェクトがエンクロージングオブジェクトへの参照を持ってしまうため、GCの対象にならない可能性がある。
* エンクロージングクラスのインスタンスにアクセスする必要が無い。非staticのメンバークラスのような危険性がありませんので、できるだけこちらを選びましょう。
  * メモリリークの危険性がないので。
```java
class Outer {
    static class Inner {
    }
}
```

## 項目25 ソースファイルを単一のトップレベルのクラスに限定する
* ソースファイルに対して複数のトップレベルクラスを定義できるが、利点はない。
  * 1つのクラスに対して複数の定義が可能になってしまう。
  * どの定義が使われるかはコンパイラの実装依存。

# 5章 ジェネリクス
## 項目26 原型を使わない
* 原型を使わない。
  * 原型を使うと、ジェネリクスの安全性と表現力の全てを失うので、原型は使うべきではない。
  * 実行時にClassCastExceptionが発生する恐れがある。
    * パラメータ化された型を使用すれば、コンパイル時にその誤りに気づくことができる。
### `List`と`List<Object>`の違い
* `List`はジェネリック型検査が行われない一方、後者はコンパイラに対して明示的に「どんなオブジェクトでも保持できること」を伝えている。
* `List`は型安全性を失うが、`List<Object>`などのパラメータ化された型を使えば型安全性を失わない。
* 型安全性
  * 型のミスマッチがある = オブジェクトに対する不正な操作の可能性がある ことをコンパイル時に発見できること。
  
### 用語
* `型パラメータ`
  * 1つ以上の型パラメータ宣言を持つクラスやインターフェースはジェネリクスクラス・ジェネリクスインターフェースである。
  * クラス名やインターフェース名の後に`<>`で囲んで定義する。
```java
class ClassName <T> {
}

interface InterfaceName <T> {
}
``` 
* `パラメータ化された型`
  * `List<String>`のように具体的な型名で定義したもの。
* `原型`
  * `List`のような型パラメータを伴わない宣言。



## まとめ
### テクニック
* スコープやメモリリークに対するテクニック
  * 通常/static/非static/無名クラスの使い分け。
* 汎用性を上げるテクニック
  * ジェネリクス
### アンチパターン
* タグ付きクラス