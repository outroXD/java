## 2章 オブジエクトの生成と消滅
### 項目1 コンストラクタの代わりにstaticファクトリメソッドを検討する
* `サブタイプ`
  * あるプログラムに対して、型Sを型Tと見なすことができる場合、「SはTのサブタイプである」という。
  * = サブクラス、派生クラス
* `派生クラス`
  * クラスの親子関係が成り立つ場合の子側のクラスのことである。
* クラスのインスタンスを使う方法。
  * publicコンストラクタの提供。
  * publicのstaticファクトリメソッドの提供。
    * クラスのインスタンスを返却するstaticメソッド。
* publicのstaticファクトリメソッド。
  * 長所
    * 名前を持つ。
      * コンストラクタだと名前はクラス名に限定される。
      * BigInteger(int, int, Random)よりBigInteger.probablePrimeというstaticファクトリメソッドの方がわかりやすい。
    * コンストラクタと異なり、呼び出し毎に新たにオブジェクトを生成する必要がない。
      * immutableクラス、オブジェクトのキャッシュ。
      * シングルトン、インスタンス化不可にできる。
    * コンストラクタと異なり、メソッドの戻り値型の任意のサブタイプのオブジェクトを返せる。
    * 返されるオブジェクトのクラスは、入力パラメータの値に応じて呼び出し毎に変えられる。
  * 短所
    * 戻り値型のサブクラスを作れない。
    
### 項目2 多くのコンストラクタパラメータに直面したときにはビルダーを検討する
* 多くのオプションパラメータがある場合にどうするかという問題。
* `テレスコーピング・コンストラクタ・パターン`が使われてきた。
  * コンストラクタを引数で数パターン用意するやり方。
* `JavaBeansパターン`
  * setterによりセットする。パラメータの正統性を確保できない。
  * setterで内部の状態を変更できるので、クラスを不変にできない。
* `Builderパターン`
  * build()でインスタンス化する前に、パラメータ間の不整合を検知できる。
  * クラス階層
  * `共変戻り値型付け`
    * サブクラスのメソッドが、スーパークラスで宣言された戻り値型のサブタイプを返すと宣言する技法。
    * 具体例はchap2のソース。
    
### 項目3 privateのコンストラクタかenum型でシングルトン特性を強制する
* シングルトンの雛形
* staticファクトリメソッドによる実装の長所。
  * ジェネリックのシングルトンファクトリをかける。
* シリアライズ可能なシングルトンクラスの実装。
  * `implements Serializable`を実装する。
  * 全てのインスタンスフィールドを`@transient`と宣言する。
  * `readResolve`メソッドを提供する。

### 項目4 privateのコンストラクタでインスタンス化不可能を強制する
* staticなフィールド・メソッドだけで構成されるクラスは、一般的にユーティリティクラスと呼ばれる。
  * そのようなクラスは本来インスタンス化して使うものではないが、コンストラクタが使えるとインスタンス化される恐れがある。
* クラスを抽象化してインスタンス化できないことを強制する。
  * そのクラスのサブクラスは作れてしまう。
  * サブクラスはインスタンス化できてしまう。
  * 継承して使うものだとユーザーを錯覚させてしまう。
* クラスのインスタンス化をできないようにする。
  * クラスにprivateのコンストラクタを含める。
  * 全てのコンストラクタは、明示的・暗黙的にスーパークラスのコンストラクタを呼び出さなければならないので、サブクラス化することも防げる。
  
### 項目5 資源を直接結び付けるよりも依存性注入を選ぶ
* 複数のインスタンスに対するサポートを提供するユーティリティ系の実装について。
  * シングルトンや静的(static)ユーティリティは不適。
  * シングルトンクラスや静的ユーティリティクラスが内部に状態を持つと、テストしづらく、状態の切り替えが必要になった時対応できない。
  * setterで内部状態にアクセス可能にする方法も考えられるが、利用者にとってわかりづらく、スレッドセーフでもない。
* `依存性注入`
  * 新しいインスタンスを生成するときにコンストラクタに資源を渡す。
* `ファクトリ`
  * 依存性注入の応用形。
  * コンストラクタに資源ファクトリを渡す。
  * `Supplier<T>`はファクトリを表現するにに最適。
#### `Supplier<T>`について。
* 引数を取らないけど、返り値は存在する挙動を定義するためのインターフェース。
* 具体例
    ```java
    // 引数なしで、型Tのインスタンスを返却する関数を実装
    Supplier<T> supplier = () -> new T();
    // 実際に呼び出す
    supplier.get();
    ```
* get()が呼ばれるまで処理が行われない為、遅延評価とも呼ばれる。