# Java Puzzlers

## Puzzle 9
* `x += i`と`x = x + i`は同じ式だと思われがちだが、違う。
* `x = x + i`は単純代入演算子(`=`)を使用している。
* `x += i`は複合代入演算子(`+=)を使用している。
* 複合代入式はそれが行う計算の結果を、左辺の変数の型へ自動的にキャストする。
  * 結果の型が変数の型と同じであれば影響しない。
  * 結果の型が変数の型よりも広ければ、基本型のナローイング変換を行うのでコンパイル時にエラーが発生する。
* 型がbyte, short, charである変数に対して複合代入演算子を使用しない。
* 複合代入演算子は暗黙のキャストを含む。ナローイング変換の場合、精度や大きさを切り捨てることになる。

## Puzzle 10

## Puzzle 12
* char型は多くのライブラリでコード値ではなく、Unicode文字を表示する。
* char[]型は文字列ではない。
  * 文字列結合演算子の振る舞い。
    1. 2つのオペランドに対して文字列変換を行う。
       * オブジェクト参照に対する文字列変換の仕様。
    2. 変換結果の文字列を結合する。
    
## Puzzle 13
* `==`演算子は比較する二つのオブジェクトが同値であるかどうかは検査しない。二つのオブジェクト参照が同一かどうかを検査する。
* `インターン(intern)`
  * 「同一の文字列を表している任意の2つのString型の定数式は、同一オブジェクト参照により表現される」。
* インターンは仮想マシンのメモリ使用量を減らすための仕組みなので、インターンに依存したコーディングは間違い。
* `equals()`を使えばオブジェクトの値を検査してくれる。

## Puzzle 14

## Puzzle 15
* Unicodeエスケープ
  * \u + 4桁の16進数で始める。
* Unicodeエスケープはコメントの中でも正しい形式出なければならない。
  * JavaDoc内ではHTMLエンティティエスケープを使用する。
  
## Puzzle 16
* コンパイラがプログラムをトークン化する前に行うこと。
  * Unicodeエスケープをそれが表している文字に変換する。
* 改行時に`char c = `\n``のようにすると、処理結果はプラットフォーム依存になる。
  * Java的にはSystem.out.println()を2回呼び出すのがいい。
  
## Puzzle 18
* 途中から65533が連続して表示された。
* byte → char → int
  * charは符号なしなので、intに変換した際は正の値であることが保証される。
* 実際の動きは「不定」らしい。
* byte列をStringへ変換する場合には、常に1つの文字セットを使用している。
  * その文字セットを明示的に指定すること。
  * String(byte[])コンストラクタはデフォルト文字セットに依存している。
  
## Puzzle 19
* 文字列リテラルはコメントないだからと言って特別に扱われるわけではない。
* 単一行コメントを利用する。

## Puzzle 20
* クラス名.class.getName()の結果をreplace()した覚えがあるが、操作対象のオブジェクトがなくてうまく実行できなかった覚えがある。

## Puzzle 24
* `b == 0x90`: 左オペランドがbyte型、右オペランドがint型の`混合型比較`になっている。
* byte型の範囲は-127〜+127なので、0x90=+144は範囲にない。よって条件式は何も表示しない。
  * byte型は符号付き整数型。
  * byte → intの格上げ(符号拡張)では、負のbyteは数値的に同じintへ変換される。
    * (byte)0x90 → intの-112へ格上げ。
    * int値の0x90である+144とは異なる。
    * intの0x90をbyteへキャストする → intとしての0x90の意味から、byteとしての0x90の意味へ変換される。.
* 混合型比較を避ける。
  * 定数を外に出す。

## Puzzle 25
* 後置インクリメントの動き。
  1. 値を保存。
  2. インクリメント
  3. (1)の値に戻す。
  
## Puzzle 26
* Integer.MAX_VALUEに1を加算するとInteger.MIN_VALUEになる。(オーバーフロー)

## Puzzle 29
* Double.NaNは「いかなる浮動小数点とも等しくなく、それ自身とも等しくない」。

## Puzzle 36
* finallyブロックから、return, break, continue, throwで抜けるのはよくない。
* finallyブロックの前のtryブロックでのそれらステートメントの結果を捨てて、finallyブロックでのステートメントを優先してしまうから。

## Puzzle 37
* catch節はtry節が「投げることのできる例外」のみcatchできる。
* メソッドが適用可能な全ての型(この場合Type1, Type2でthrowする型)のことで、それら型のメソッドがスローすると宣言している例外の集合の積。

## Puzzle 38
* 「安全」だがfinalで定義されたフィールドに代入できないケース。
* Javaの仕様では「ブランクfinalフィールドへの代入は。確実に未代入な箇所でしか行えない」。

## Puzzle 39
* System.exit()は現在のスレッドと、他の全てのスレッドを終了させる。
* finally節の中であっても、そこで終了させる。
* VM終了前に実行したい処理がある場合、シャットダウンフックを使用すること。

## Puzzle 40
* 例題だとStackOverflowで落ちる。
* コンストラクタより先にクラスのフィールド変数のインスタンス化処理が先に実行され、無限に再帰実行されるのが原因。

## Puzzle 41
* finallyブロックでcloseメソッドを呼びだす場合、IOExceptionの伝搬をなくす為に、ネストしたtry-catchで保護する。

## Puzzle 42
* ループ制御に例外を使用すると速度が遅くなる。
* 配列のイテレーションにはwhileではなく、for(for-each)を使うのが良い。

## Puzzle 44
* クラスが存在しないことを検出するプログラムを書くには、リフレクションを使用する。

## Puzzle 45
* try-finallyでなければ、StackOverflowを起こすまで再帰される。
* Java仮想マシンは設定でスタックの深さを調整できる。

## Puzzle 46
* 全てのdouble配列はObjectだが、Objectがdouble配列とは限らない。
* Javaのオーバーロード解決処理
  1. アクセス可能で適用可能な全てのメソッド・コンストラクタが選択される。
  2. (1)で選択された物の中から「最も限定的なもの」が選択される。
* 限定的かどうか(2の検査)では、「引数の値が何か」という情報をコンパイラは使用しない。
* 理想としてはオーバーロードを避けるべき。
* オーバーロードを行う場合は、お互いに互換性のない引数を取ることを保証する必要がある。

## Puzzle47
* Counter内部ではcountがstatic変数なので、宣言されたクラス・そのサブクラス間で共有されている。
  * 理想の動きはペットの種類ごとにカウンタを持つこと。
* 他のクラスの振る舞いの上に構築されるクラスを設計する。
  * クラスが他のクラスを拡張する継承。
    * 継承を使用。
  * クラスが他のクラスのインスタンスを保持しているコンポジション。
    * コンポジションを使用。
    
## Puzzle 48
* staticメソッドは動的ディスパッチは行われない。
  * 呼び出されるメソッドは修飾子のコンパイル時の型に基づいて、コンパイル時に選択される。
* 動的ディスパッチ
  * 動的にメソッドを呼びだすこと。
* static修飾子をつけると静的にディスパッチされる。
  * クラスが使用されることを読み手は期待する。(?)
  * この場合、BasenjiがDogを継承(修飾)しているように見える。
  * 同じ識別子 = オーバーライドを期待する。
* オーバーライドでは動的ディスパッチが行われるが、隠蔽は行われない。

## Puzzle 50
* instanceof演算子の左オペランドでnull参照された場合、必ずfalseを返す。
  * 例)Type1
* instanceof演算子では両方のオペランドがクラス型の場合、1つは他方のサブタイプでなければならない。
  * 条件を満たさない場合、例外を投げる。
  * 例)Type2
* コンパイル時にエラーを投げてくれないケース。
  * 上記の条件を満たしているが、Obhect型がType3型のサブタイプになり得ないことをコンパイラは拾ってくれない。
  
## Puzzle 51
* finalフィールドであっても、初期化前に読み出すことができる(nullを取得できる)事による意図しない動作。
* 循環したインスタンス初期化は回避することができるし、するべき。
  * コンストラクタがサブクラスでオーバーライドされたメソッドを呼びだすケース。
    * コンストラクタからオーバーライド可能なメソッドを呼び出さないこと。
    * 遅延初期化。
    
## Puzzle 52
* 積極的な初期化か遅延初期化のどちらかのみを使うこと。
* 積極的な初期化
  * フィールドを初期化する時間とコストが低い場合。

## Puzzle 53
* プライベート・コンストラクタ・キャプチャパターン。

## Puzzle54
* nullポインターエクセプションをスローしそうに見えるが、クラスのメソッドを呼びだす。
* staticメソット呼び出しに対して、修飾を行っている式は。評価はされるが、その値は無視される。

## Puzzle 55
* for, while, doループでブロックを省略したとき、その中でローカル変数宣言を行うことはできない。

## Puzzle 56
* BigInteger, Integer, Long, Short, Byte, Character, Boolean, Float, BigDecimalは`不変型`。
* 不変型はインスタンスを変更しない。変更しない代わりに新しくインスタンスを作って返す。

## Puzzle 57
* equalsをオーバーライドしたら、hashCodeもオーバーライドすること。

## Puzzle 58
* equalsはObject型から継承される。
* Object型から継承されるequalsは`equals(Object)`。
  * なので、`equals(Name)`で実装しても影響しない。
  
## Puzzle 59
* 0で始まる整数リテラルは、8進数として解釈される。

## Puzzle 60
* LinkedHashSet
  * 順序を保った集合。
* deepToString
  * 多次元配列の中身を文字列にして表示する。

## Puzzle 61
* CalendarクラスのDateは1月を0で表す。

## Puzzle 62
* 文字列定数はインターンされる。
  * 等価な文字列定数は、「同一」である。

## Puzzle 65
* compareの中の差分計算処理が「型の範囲」を超える場合にオーバーフローして正しく動作しない。
* 比較は`推移的`である必要がある。
  * `(compare(x, y) > 0) && (compare(y, z) > 0)`ならば`compare(x, z) > 0`
* 順序を逆順にする場合は、`Arrays.sort(arr, Collections.reverseOrder())`を使うのが楽。
* 2つの値の差が絶対にInteger.MAX_VALUEより大きくならないことを約束できないのであれば、引き算に基づく計算をしない。

## Puzzle 66
* オーバーライドしているメソッドのアクセス修飾子は、オーバーライドされているメソッドのアクセス修飾子よりも`同等以上のアクセスが可能`でなければならない。
* classNameはフィールドなので、Base.classNameをオーバーライドするのではなく、`隠蔽`している。
* オーバーライドと隠蔽の違い。
  * サブクラスでオーバーライドされると、サブクラスのインスタンスに対して、(スーパークラスの)そのメソッドを呼び出すことはできない。
  * サブクラスのインスタンスをスーパークラスへキャストすることで呼び出すことができる。
* `リスコフの置換原則`
  * 基底クラスに対してできることは全て、派生クラスでもできなくてはならない。
* `包摂の原則`が破られるケース。
  * 2つのフィールドの型が異なる。
  * 一方のフィールドがstaticで、他方がstaticでない。
  * 一方のフィールドがfinalで、他方がfinalでない。
  * 一方のフィールドが定数で、他方が定数でない。
  * 両方のフィールドが定数で、異なる値の場合。
  
## Puzzle 67
* プラットフォームが提供しているクラス名は使用しない。

## Puzzle 68
* 変数と型が同じ名前で、同じスコープにある場合、変数名が優先される。

## Puzzle 69
* オブスキュアされた型名を参照することは不可能。
* 変数は許されないが、型名が許される文法的文脈で、名前を使用すること。
  * キャスト式の括弧内。
* staticで修飾しないとNullPointerExceptionで落ちた。

## Puzzle 70
* パッケージプライベートのメソッドは、異なるパッケージの中のメソッドで直接オーバーライドすることはできない。